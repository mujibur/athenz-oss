//
// This file generated by rdl 1.4.10
//

package zts

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// SimpleName - Copyright 2016 Yahoo Inc. Licensed under the terms of the
// Apache version 2.0 license. See LICENSE file for terms. Common name types
// used by several API definitions A simple identifier, an element of compound
// name.
//
type SimpleName string

//
// CompoundName - A compound name. Most names in this API are compound names.
//
type CompoundName string

//
// DomainName - A domain name is the general qualifier prefix, as its
// uniqueness is managed.
//
type DomainName string

//
// EntityName - An entity name is a short form of a resource name, including
// only the domain and entity.
//
type EntityName string

//
// ServiceName - A service name will generally be a unique subdomain.
//
type ServiceName string

//
// ActionName - An action (operation) name.
//
type ActionName string

//
// ResourceName - A resource name Note that the EntityName part is optional,
// that is, a domain name followed by a colon is valid resource name.
//
type ResourceName string

//
// YBase64 - The Y-specific URL-safe Base64 variant.
//
type YBase64 string

//
// YEncoded - YEncoded includes ybase64 chars, as well as = and %. This can
// represent a user cookie and URL-encoded values.
//
type YEncoded string

//
// AuthorityName - Used as the prefix in a signed assertion. This uniquely
// identifies a signing authority.
//
type AuthorityName string

//
// SignedToken - A signed assertion if identity. i.e. the user cookie value.
// This token will only make sense to the authority that generated it, so it is
// beneficial to have something in the value that is cheaply recognized to
// quickly reject if it belongs to another authority. In addition to the
// YEncoded set our token includes ; to separate components and , to separate
// roles
//
type SignedToken string

//
// PublicKeyEntry - The representation of the public key in a service identity
// object.
//
type PublicKeyEntry struct {

	//
	// the public key for the service
	//
	Key string `json:"key"`

	//
	// the key identifier (version or zone name)
	//
	Id string `json:"id"`
}

//
// NewPublicKeyEntry - creates an initialized PublicKeyEntry instance, returns a pointer to it
//
func NewPublicKeyEntry(init ...*PublicKeyEntry) *PublicKeyEntry {
	var o *PublicKeyEntry
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PublicKeyEntry)
	}
	return o
}

type rawPublicKeyEntry PublicKeyEntry

//
// UnmarshalJSON is defined for proper JSON decoding of a PublicKeyEntry
//
func (pTypeDef *PublicKeyEntry) UnmarshalJSON(b []byte) error {
	var r rawPublicKeyEntry
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := PublicKeyEntry(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *PublicKeyEntry) Validate() error {
	if pTypeDef.Key == "" {
		return fmt.Errorf("PublicKeyEntry.key is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Key)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.key does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Id == "" {
		return fmt.Errorf("PublicKeyEntry.id is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Id)
		if !val.Valid {
			return fmt.Errorf("PublicKeyEntry.id does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentity - The representation of the service identity object.
//
type ServiceIdentity struct {

	//
	// the full name of the service, i.e. "sports.storage"
	//
	Name ServiceName `json:"name"`

	//
	// array of public keys for key rotation
	//
	PublicKeys []*PublicKeyEntry `json:"publicKeys,omitempty" rdl:"optional"`

	//
	// if present, then this service can provision tenants via this endpoint.
	//
	ProviderEndpoint string `json:"providerEndpoint,omitempty" rdl:"optional"`

	//
	// the timestamp when this entry was last modified
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// the path of the executable that runs the service
	//
	Executable string `json:"executable,omitempty" rdl:"optional"`

	//
	// list of host names that this service can run on
	//
	Hosts []string `json:"hosts,omitempty" rdl:"optional"`

	//
	// local (unix) user name this service can run as
	//
	User string `json:"user,omitempty" rdl:"optional"`

	//
	// local (unix) group name this service can run as
	//
	Group string `json:"group,omitempty" rdl:"optional"`
}

//
// NewServiceIdentity - creates an initialized ServiceIdentity instance, returns a pointer to it
//
func NewServiceIdentity(init ...*ServiceIdentity) *ServiceIdentity {
	var o *ServiceIdentity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentity)
	}
	return o
}

type rawServiceIdentity ServiceIdentity

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentity
//
func (pTypeDef *ServiceIdentity) UnmarshalJSON(b []byte) error {
	var r rawServiceIdentity
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServiceIdentity(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServiceIdentity) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("ServiceIdentity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "ServiceName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("ServiceIdentity.name does not contain a valid ServiceName (%v)", val.Error)
		}
	}
	return nil
}

//
// ServiceIdentityList - The representation for an enumeration of services in
// the namespace.
//
type ServiceIdentityList struct {

	//
	// list of service names
	//
	Names []EntityName `json:"names"`
}

//
// NewServiceIdentityList - creates an initialized ServiceIdentityList instance, returns a pointer to it
//
func NewServiceIdentityList(init ...*ServiceIdentityList) *ServiceIdentityList {
	var o *ServiceIdentityList
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(ServiceIdentityList)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *ServiceIdentityList) Init() *ServiceIdentityList {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawServiceIdentityList ServiceIdentityList

//
// UnmarshalJSON is defined for proper JSON decoding of a ServiceIdentityList
//
func (pTypeDef *ServiceIdentityList) UnmarshalJSON(b []byte) error {
	var r rawServiceIdentityList
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := ServiceIdentityList(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *ServiceIdentityList) Validate() error {
	if pTypeDef.Names == nil {
		return fmt.Errorf("ServiceIdentityList: Missing required field: names")
	}
	return nil
}

//
// HostServices - The representation for an enumeration of services authorized
// to run on a specific host.
//
type HostServices struct {

	//
	// name of the host
	//
	Host string `json:"host"`

	//
	// list of service names authorized to run on this host
	//
	Names []EntityName `json:"names"`
}

//
// NewHostServices - creates an initialized HostServices instance, returns a pointer to it
//
func NewHostServices(init ...*HostServices) *HostServices {
	var o *HostServices
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(HostServices)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *HostServices) Init() *HostServices {
	if pTypeDef.Names == nil {
		pTypeDef.Names = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawHostServices HostServices

//
// UnmarshalJSON is defined for proper JSON decoding of a HostServices
//
func (pTypeDef *HostServices) UnmarshalJSON(b []byte) error {
	var r rawHostServices
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := HostServices(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *HostServices) Validate() error {
	if pTypeDef.Host == "" {
		return fmt.Errorf("HostServices.host is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Host)
		if !val.Valid {
			return fmt.Errorf("HostServices.host does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Names == nil {
		return fmt.Errorf("HostServices: Missing required field: names")
	}
	return nil
}

//
// AssertionEffect - Every assertion can have the effect of ALLOW or DENY.
//
type AssertionEffect int

//
// AssertionEffect constants
//
const (
	_ AssertionEffect = iota
	ALLOW
	DENY
)

var namesAssertionEffect = []string{
	ALLOW: "ALLOW",
	DENY:  "DENY",
}

//
// NewAssertionEffect - return a string representation of the enum
//
func NewAssertionEffect(init ...interface{}) AssertionEffect {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case AssertionEffect:
			return v
		case int:
			return AssertionEffect(v)
		case int32:
			return AssertionEffect(v)
		case string:
			for i, s := range namesAssertionEffect {
				if s == v {
					return AssertionEffect(i)
				}
			}
		default:
			panic("Bad init value for AssertionEffect enum")
		}
	}
	return AssertionEffect(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e AssertionEffect) String() string {
	return namesAssertionEffect[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e AssertionEffect) SymbolSet() []string {
	return namesAssertionEffect
}

//
// MarshalJSON is defined for proper JSON encoding of a AssertionEffect
//
func (e AssertionEffect) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a AssertionEffect
//
func (e *AssertionEffect) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesAssertionEffect {
			if s == s2 {
				*e = AssertionEffect(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type AssertionEffect: %s", s)
	}
	return err
}

//
// Assertion - A representation for the encapsulation of an action to be
// performed on a resource by a principal.
//
type Assertion struct {

	//
	// the subject of the assertion, a role
	//
	Role string `json:"role"`

	//
	// the object of the assertion. Must be in the local namespace. Can contain
	// wildcards
	//
	Resource string `json:"resource"`

	//
	// the predicate of the assertion. Can contain wildcards
	//
	Action string `json:"action"`

	//
	// the effect of the assertion in the policy language
	//
	Effect *AssertionEffect `json:"effect,omitempty" rdl:"optional"`

	//
	// assertion id - auto generated by server
	//
	Id *int64 `json:"id,omitempty" rdl:"optional"`
}

//
// NewAssertion - creates an initialized Assertion instance, returns a pointer to it
//
func NewAssertion(init ...*Assertion) *Assertion {
	var o *Assertion
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Assertion)
	}
	return o
}

type rawAssertion Assertion

//
// UnmarshalJSON is defined for proper JSON decoding of a Assertion
//
func (pTypeDef *Assertion) UnmarshalJSON(b []byte) error {
	var r rawAssertion
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Assertion(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Assertion) Validate() error {
	if pTypeDef.Role == "" {
		return fmt.Errorf("Assertion.role is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Role)
		if !val.Valid {
			return fmt.Errorf("Assertion.role does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Resource == "" {
		return fmt.Errorf("Assertion.resource is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Resource)
		if !val.Valid {
			return fmt.Errorf("Assertion.resource does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Action == "" {
		return fmt.Errorf("Assertion.action is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Action)
		if !val.Valid {
			return fmt.Errorf("Assertion.action does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Policy - The representation for a Policy with set of assertions.
//
type Policy struct {

	//
	// name of the policy
	//
	Name ResourceName `json:"name"`

	//
	// last modification timestamp of this policy
	//
	Modified *rdl.Timestamp `json:"modified,omitempty" rdl:"optional"`

	//
	// list of defined assertions for this policy
	//
	Assertions []*Assertion `json:"assertions"`
}

//
// NewPolicy - creates an initialized Policy instance, returns a pointer to it
//
func NewPolicy(init ...*Policy) *Policy {
	var o *Policy
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Policy)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *Policy) Init() *Policy {
	if pTypeDef.Assertions == nil {
		pTypeDef.Assertions = make([]*Assertion, 0)
	}
	return pTypeDef
}

type rawPolicy Policy

//
// UnmarshalJSON is defined for proper JSON decoding of a Policy
//
func (pTypeDef *Policy) UnmarshalJSON(b []byte) error {
	var r rawPolicy
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Policy(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Policy) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Policy.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "ResourceName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Policy.name does not contain a valid ResourceName (%v)", val.Error)
		}
	}
	if pTypeDef.Assertions == nil {
		return fmt.Errorf("Policy: Missing required field: assertions")
	}
	return nil
}

//
// PolicyData -
//
type PolicyData struct {

	//
	// name of the domain
	//
	Domain DomainName `json:"domain"`

	//
	// list of policies defined in this server
	//
	Policies []*Policy `json:"policies"`
}

//
// NewPolicyData - creates an initialized PolicyData instance, returns a pointer to it
//
func NewPolicyData(init ...*PolicyData) *PolicyData {
	var o *PolicyData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(PolicyData)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *PolicyData) Init() *PolicyData {
	if pTypeDef.Policies == nil {
		pTypeDef.Policies = make([]*Policy, 0)
	}
	return pTypeDef
}

type rawPolicyData PolicyData

//
// UnmarshalJSON is defined for proper JSON decoding of a PolicyData
//
func (pTypeDef *PolicyData) UnmarshalJSON(b []byte) error {
	var r rawPolicyData
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := PolicyData(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *PolicyData) Validate() error {
	if pTypeDef.Domain == "" {
		return fmt.Errorf("PolicyData.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "DomainName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("PolicyData.domain does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.Policies == nil {
		return fmt.Errorf("PolicyData: Missing required field: policies")
	}
	return nil
}

//
// SignedPolicyData - A representation of policies object defined in a given
// server.
//
type SignedPolicyData struct {

	//
	// list of policies defined in a domain
	//
	PolicyData *PolicyData `json:"policyData"`

	//
	// zms signature generated based on the domain policies object
	//
	ZmsSignature string `json:"zmsSignature"`

	//
	// the identifier of the zms key used to generate the signature
	//
	ZmsKeyId string `json:"zmsKeyId"`

	//
	// when the domain itself was last modified
	//
	Modified rdl.Timestamp `json:"modified"`

	//
	// timestamp specifying the expiration time for using this set of policies
	//
	Expires rdl.Timestamp `json:"expires"`
}

//
// NewSignedPolicyData - creates an initialized SignedPolicyData instance, returns a pointer to it
//
func NewSignedPolicyData(init ...*SignedPolicyData) *SignedPolicyData {
	var o *SignedPolicyData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SignedPolicyData)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *SignedPolicyData) Init() *SignedPolicyData {
	if pTypeDef.PolicyData == nil {
		pTypeDef.PolicyData = NewPolicyData()
	}
	return pTypeDef
}

type rawSignedPolicyData SignedPolicyData

//
// UnmarshalJSON is defined for proper JSON decoding of a SignedPolicyData
//
func (pTypeDef *SignedPolicyData) UnmarshalJSON(b []byte) error {
	var r rawSignedPolicyData
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := SignedPolicyData(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *SignedPolicyData) Validate() error {
	if pTypeDef.PolicyData == nil {
		return fmt.Errorf("SignedPolicyData: Missing required field: policyData")
	}
	if pTypeDef.ZmsSignature == "" {
		return fmt.Errorf("SignedPolicyData.zmsSignature is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.ZmsSignature)
		if !val.Valid {
			return fmt.Errorf("SignedPolicyData.zmsSignature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.ZmsKeyId == "" {
		return fmt.Errorf("SignedPolicyData.zmsKeyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.ZmsKeyId)
		if !val.Valid {
			return fmt.Errorf("SignedPolicyData.zmsKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Modified.IsZero() {
		return fmt.Errorf("SignedPolicyData: Missing required field: modified")
	}
	if pTypeDef.Expires.IsZero() {
		return fmt.Errorf("SignedPolicyData: Missing required field: expires")
	}
	return nil
}

//
// DomainSignedPolicyData - A signed bulk transfer of policies. The data is
// signed with server's private key.
//
type DomainSignedPolicyData struct {

	//
	// policy data signed by ZMS
	//
	SignedPolicyData *SignedPolicyData `json:"signedPolicyData"`

	//
	// signature generated based on the domain policies object
	//
	Signature string `json:"signature"`

	//
	// the identifier of the key used to generate the signature
	//
	KeyId string `json:"keyId"`
}

//
// NewDomainSignedPolicyData - creates an initialized DomainSignedPolicyData instance, returns a pointer to it
//
func NewDomainSignedPolicyData(init ...*DomainSignedPolicyData) *DomainSignedPolicyData {
	var o *DomainSignedPolicyData
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainSignedPolicyData)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainSignedPolicyData) Init() *DomainSignedPolicyData {
	if pTypeDef.SignedPolicyData == nil {
		pTypeDef.SignedPolicyData = NewSignedPolicyData()
	}
	return pTypeDef
}

type rawDomainSignedPolicyData DomainSignedPolicyData

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainSignedPolicyData
//
func (pTypeDef *DomainSignedPolicyData) UnmarshalJSON(b []byte) error {
	var r rawDomainSignedPolicyData
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainSignedPolicyData(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainSignedPolicyData) Validate() error {
	if pTypeDef.SignedPolicyData == nil {
		return fmt.Errorf("DomainSignedPolicyData: Missing required field: signedPolicyData")
	}
	if pTypeDef.Signature == "" {
		return fmt.Errorf("DomainSignedPolicyData.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Signature)
		if !val.Valid {
			return fmt.Errorf("DomainSignedPolicyData.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.KeyId == "" {
		return fmt.Errorf("DomainSignedPolicyData.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.KeyId)
		if !val.Valid {
			return fmt.Errorf("DomainSignedPolicyData.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleToken - A representation of a signed RoleToken
//
type RoleToken struct {
	Token      string `json:"token"`
	ExpiryTime int64  `json:"expiryTime"`
}

//
// NewRoleToken - creates an initialized RoleToken instance, returns a pointer to it
//
func NewRoleToken(init ...*RoleToken) *RoleToken {
	var o *RoleToken
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleToken)
	}
	return o
}

type rawRoleToken RoleToken

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleToken
//
func (pTypeDef *RoleToken) UnmarshalJSON(b []byte) error {
	var r rawRoleToken
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleToken(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleToken) Validate() error {
	if pTypeDef.Token == "" {
		return fmt.Errorf("RoleToken.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Token)
		if !val.Valid {
			return fmt.Errorf("RoleToken.token does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// RoleCertificateRequest - RoleCertificateRequest - a certificate signing
// request
//
type RoleCertificateRequest struct {
	Csr        string `json:"csr"`
	ExpiryTime int64  `json:"expiryTime"`
}

//
// NewRoleCertificateRequest - creates an initialized RoleCertificateRequest instance, returns a pointer to it
//
func NewRoleCertificateRequest(init ...*RoleCertificateRequest) *RoleCertificateRequest {
	var o *RoleCertificateRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleCertificateRequest)
	}
	return o
}

type rawRoleCertificateRequest RoleCertificateRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleCertificateRequest
//
func (pTypeDef *RoleCertificateRequest) UnmarshalJSON(b []byte) error {
	var r rawRoleCertificateRequest
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleCertificateRequest(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleCertificateRequest) Validate() error {
	if pTypeDef.Csr == "" {
		return fmt.Errorf("RoleCertificateRequest.csr is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Csr)
		if !val.Valid {
			return fmt.Errorf("RoleCertificateRequest.csr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Access - Access can be checked and returned as this resource.
//
type Access struct {

	//
	// true (allowed) or false (denied)
	//
	Granted bool `json:"granted"`
}

//
// NewAccess - creates an initialized Access instance, returns a pointer to it
//
func NewAccess(init ...*Access) *Access {
	var o *Access
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Access)
	}
	return o
}

type rawAccess Access

//
// UnmarshalJSON is defined for proper JSON decoding of a Access
//
func (pTypeDef *Access) UnmarshalJSON(b []byte) error {
	var r rawAccess
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Access(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Access) Validate() error {
	return nil
}

//
// RoleAccess -
//
type RoleAccess struct {
	Roles []EntityName `json:"roles"`
}

//
// NewRoleAccess - creates an initialized RoleAccess instance, returns a pointer to it
//
func NewRoleAccess(init ...*RoleAccess) *RoleAccess {
	var o *RoleAccess
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(RoleAccess)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *RoleAccess) Init() *RoleAccess {
	if pTypeDef.Roles == nil {
		pTypeDef.Roles = make([]EntityName, 0)
	}
	return pTypeDef
}

type rawRoleAccess RoleAccess

//
// UnmarshalJSON is defined for proper JSON decoding of a RoleAccess
//
func (pTypeDef *RoleAccess) UnmarshalJSON(b []byte) error {
	var r rawRoleAccess
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := RoleAccess(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *RoleAccess) Validate() error {
	if pTypeDef.Roles == nil {
		return fmt.Errorf("RoleAccess: Missing required field: roles")
	}
	return nil
}

//
// TenantDomains -
//
type TenantDomains struct {
	TenantDomainNames []DomainName `json:"tenantDomainNames"`
}

//
// NewTenantDomains - creates an initialized TenantDomains instance, returns a pointer to it
//
func NewTenantDomains(init ...*TenantDomains) *TenantDomains {
	var o *TenantDomains
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(TenantDomains)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *TenantDomains) Init() *TenantDomains {
	if pTypeDef.TenantDomainNames == nil {
		pTypeDef.TenantDomainNames = make([]DomainName, 0)
	}
	return pTypeDef
}

type rawTenantDomains TenantDomains

//
// UnmarshalJSON is defined for proper JSON decoding of a TenantDomains
//
func (pTypeDef *TenantDomains) UnmarshalJSON(b []byte) error {
	var r rawTenantDomains
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := TenantDomains(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *TenantDomains) Validate() error {
	if pTypeDef.TenantDomainNames == nil {
		return fmt.Errorf("TenantDomains: Missing required field: tenantDomainNames")
	}
	return nil
}

//
// Identity - Identity - a signed assertion of service or human identity, the
// response could be either a client certificate or just a regular NToken
// (depending if the request contained a csr or not).
//
type Identity struct {

	//
	// name of the identity, fully qualified, i.e. my.domain.service1, or
	// aws.1232321321312.myusername
	//
	Name CompoundName `json:"name"`

	//
	// a certificate usable for both client and server in TLS connections
	//
	Certificate string `json:"certificate,omitempty" rdl:"optional"`

	//
	// the CA certificate chain to use with all IMS-generated certs
	//
	CaCertBundle string `json:"caCertBundle,omitempty" rdl:"optional"`

	//
	// the SSH server cert, signed by the CA
	//
	SshServerCert string `json:"sshServerCert,omitempty" rdl:"optional"`

	//
	// service token instead of TLS certificate
	//
	ServiceToken SignedToken `json:"serviceToken,omitempty" rdl:"optional"`

	//
	// other config-like attributes determined at boot time
	//
	Attributes map[string]string `json:"attributes,omitempty" rdl:"optional"`
}

//
// NewIdentity - creates an initialized Identity instance, returns a pointer to it
//
func NewIdentity(init ...*Identity) *Identity {
	var o *Identity
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Identity)
	}
	return o
}

type rawIdentity Identity

//
// UnmarshalJSON is defined for proper JSON decoding of a Identity
//
func (pTypeDef *Identity) UnmarshalJSON(b []byte) error {
	var r rawIdentity
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := Identity(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *Identity) Validate() error {
	if pTypeDef.Name == "" {
		return fmt.Errorf("Identity.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "CompoundName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("Identity.name does not contain a valid CompoundName (%v)", val.Error)
		}
	}
	return nil
}

//
// InstanceInformation - Instance object that includes requested service
// details plus host document that is signed by provider as part of the host
// bootstrap process
//
type InstanceInformation struct {

	//
	// signed document containing attributes like IP address, instance-id,
	// account#, etc.
	//
	Document string `json:"document"`

	//
	// the signature for the document
	//
	Signature string `json:"signature"`

	//
	// the keyid used to sign the document
	//
	KeyId string `json:"keyId"`

	//
	// the domain of the instance
	//
	Domain CompoundName `json:"domain"`

	//
	// the service this instance is supposed to run
	//
	Service SimpleName `json:"service"`

	//
	// return a certificate in the response
	//
	Csr string `json:"csr"`
}

//
// NewInstanceInformation - creates an initialized InstanceInformation instance, returns a pointer to it
//
func NewInstanceInformation(init ...*InstanceInformation) *InstanceInformation {
	var o *InstanceInformation
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(InstanceInformation)
	}
	return o
}

type rawInstanceInformation InstanceInformation

//
// UnmarshalJSON is defined for proper JSON decoding of a InstanceInformation
//
func (pTypeDef *InstanceInformation) UnmarshalJSON(b []byte) error {
	var r rawInstanceInformation
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := InstanceInformation(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *InstanceInformation) Validate() error {
	if pTypeDef.Document == "" {
		return fmt.Errorf("InstanceInformation.document is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Document)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.document does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Signature == "" {
		return fmt.Errorf("InstanceInformation.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Signature)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.KeyId == "" {
		return fmt.Errorf("InstanceInformation.keyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.KeyId)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.keyId does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Domain == "" {
		return fmt.Errorf("InstanceInformation.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "CompoundName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.domain does not contain a valid CompoundName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("InstanceInformation.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "SimpleName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Csr == "" {
		return fmt.Errorf("InstanceInformation.csr is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Csr)
		if !val.Valid {
			return fmt.Errorf("InstanceInformation.csr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// InstanceRefreshRequest - InstanceRefreshRequest - a certificate refresh
// request
//
type InstanceRefreshRequest struct {

	//
	// Cert CSR if requesting TLS certificate
	//
	Csr string `json:"csr"`

	//
	// in seconds how long token should be valid for
	//
	ExpiryTime *int32 `json:"expiryTime,omitempty" rdl:"optional"`
}

//
// NewInstanceRefreshRequest - creates an initialized InstanceRefreshRequest instance, returns a pointer to it
//
func NewInstanceRefreshRequest(init ...*InstanceRefreshRequest) *InstanceRefreshRequest {
	var o *InstanceRefreshRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(InstanceRefreshRequest)
	}
	return o
}

type rawInstanceRefreshRequest InstanceRefreshRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a InstanceRefreshRequest
//
func (pTypeDef *InstanceRefreshRequest) UnmarshalJSON(b []byte) error {
	var r rawInstanceRefreshRequest
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := InstanceRefreshRequest(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *InstanceRefreshRequest) Validate() error {
	if pTypeDef.Csr == "" {
		return fmt.Errorf("InstanceRefreshRequest.csr is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Csr)
		if !val.Valid {
			return fmt.Errorf("InstanceRefreshRequest.csr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// AWSInstanceInformation - AWSInstanceInformation - the information a booting
// EC2 instance must provide to ZTS to authenticate.
//
type AWSInstanceInformation struct {

	//
	// signed document containing attributes like IP address, instance-id,
	// account#, etc.
	//
	Document string `json:"document"`

	//
	// the signature for the document
	//
	Signature string `json:"signature"`

	//
	// the domain of the instance
	//
	Domain CompoundName `json:"domain"`

	//
	// the service this instance is supposed to run
	//
	Service SimpleName `json:"service"`

	//
	// return a certificate in the response
	//
	Csr string `json:"csr"`

	//
	// the full service identity name (same as the EC2 instance profile name)
	//
	Name CompoundName `json:"name"`

	//
	// the account id (as a string) for the instance. parsed from the instance
	// profile ARN
	//
	Account SimpleName `json:"account"`

	//
	// the name of the cloud (namespace) within the account, parsed from the name
	//
	Cloud SimpleName `json:"cloud,omitempty" rdl:"optional"`

	//
	// the name of the subnet this instance is expected to be running in, parsed
	// from the name
	//
	Subnet SimpleName `json:"subnet"`

	//
	// the AWS Access Key Id for the role
	//
	Access string `json:"access"`

	//
	// the AWS Secret Access Key for the role
	//
	Secret string `json:"secret"`

	//
	// the AWS STS Token for the role
	//
	Token string `json:"token"`

	//
	// the expiration time of the access keys
	//
	Expires rdl.Timestamp `json:"expires"`

	//
	// the modified time of the access keys
	//
	Modified rdl.Timestamp `json:"modified"`

	//
	// the 'flavor' of the access keys, i.e. "AWS-HMAC"
	//
	Flavor string `json:"flavor"`
}

//
// NewAWSInstanceInformation - creates an initialized AWSInstanceInformation instance, returns a pointer to it
//
func NewAWSInstanceInformation(init ...*AWSInstanceInformation) *AWSInstanceInformation {
	var o *AWSInstanceInformation
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AWSInstanceInformation)
	}
	return o
}

type rawAWSInstanceInformation AWSInstanceInformation

//
// UnmarshalJSON is defined for proper JSON decoding of a AWSInstanceInformation
//
func (pTypeDef *AWSInstanceInformation) UnmarshalJSON(b []byte) error {
	var r rawAWSInstanceInformation
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := AWSInstanceInformation(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *AWSInstanceInformation) Validate() error {
	if pTypeDef.Document == "" {
		return fmt.Errorf("AWSInstanceInformation.document is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Document)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.document does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Signature == "" {
		return fmt.Errorf("AWSInstanceInformation.signature is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Signature)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.signature does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Domain == "" {
		return fmt.Errorf("AWSInstanceInformation.domain is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "CompoundName", pTypeDef.Domain)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.domain does not contain a valid CompoundName (%v)", val.Error)
		}
	}
	if pTypeDef.Service == "" {
		return fmt.Errorf("AWSInstanceInformation.service is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "SimpleName", pTypeDef.Service)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.service does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Csr == "" {
		return fmt.Errorf("AWSInstanceInformation.csr is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Csr)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.csr does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Name == "" {
		return fmt.Errorf("AWSInstanceInformation.name is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "CompoundName", pTypeDef.Name)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.name does not contain a valid CompoundName (%v)", val.Error)
		}
	}
	if pTypeDef.Account == "" {
		return fmt.Errorf("AWSInstanceInformation.account is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "SimpleName", pTypeDef.Account)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.account does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Subnet == "" {
		return fmt.Errorf("AWSInstanceInformation.subnet is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "SimpleName", pTypeDef.Subnet)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.subnet does not contain a valid SimpleName (%v)", val.Error)
		}
	}
	if pTypeDef.Access == "" {
		return fmt.Errorf("AWSInstanceInformation.access is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Access)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.access does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Secret == "" {
		return fmt.Errorf("AWSInstanceInformation.secret is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Secret)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.secret does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Token == "" {
		return fmt.Errorf("AWSInstanceInformation.token is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Token)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.token does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Expires.IsZero() {
		return fmt.Errorf("AWSInstanceInformation: Missing required field: expires")
	}
	if pTypeDef.Modified.IsZero() {
		return fmt.Errorf("AWSInstanceInformation: Missing required field: modified")
	}
	if pTypeDef.Flavor == "" {
		return fmt.Errorf("AWSInstanceInformation.flavor is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Flavor)
		if !val.Valid {
			return fmt.Errorf("AWSInstanceInformation.flavor does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// AWSCertificateRequest - AWSCertificateRequest - a certificate signing
// request
//
type AWSCertificateRequest struct {
	Csr string `json:"csr"`
}

//
// NewAWSCertificateRequest - creates an initialized AWSCertificateRequest instance, returns a pointer to it
//
func NewAWSCertificateRequest(init ...*AWSCertificateRequest) *AWSCertificateRequest {
	var o *AWSCertificateRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AWSCertificateRequest)
	}
	return o
}

type rawAWSCertificateRequest AWSCertificateRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a AWSCertificateRequest
//
func (pTypeDef *AWSCertificateRequest) UnmarshalJSON(b []byte) error {
	var r rawAWSCertificateRequest
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := AWSCertificateRequest(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *AWSCertificateRequest) Validate() error {
	if pTypeDef.Csr == "" {
		return fmt.Errorf("AWSCertificateRequest.csr is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.Csr)
		if !val.Valid {
			return fmt.Errorf("AWSCertificateRequest.csr does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// AWSTemporaryCredentials -
//
type AWSTemporaryCredentials struct {
	AccessKeyId     string        `json:"accessKeyId"`
	SecretAccessKey string        `json:"secretAccessKey"`
	SessionToken    string        `json:"sessionToken"`
	Expiration      rdl.Timestamp `json:"expiration"`
}

//
// NewAWSTemporaryCredentials - creates an initialized AWSTemporaryCredentials instance, returns a pointer to it
//
func NewAWSTemporaryCredentials(init ...*AWSTemporaryCredentials) *AWSTemporaryCredentials {
	var o *AWSTemporaryCredentials
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(AWSTemporaryCredentials)
	}
	return o
}

type rawAWSTemporaryCredentials AWSTemporaryCredentials

//
// UnmarshalJSON is defined for proper JSON decoding of a AWSTemporaryCredentials
//
func (pTypeDef *AWSTemporaryCredentials) UnmarshalJSON(b []byte) error {
	var r rawAWSTemporaryCredentials
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := AWSTemporaryCredentials(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *AWSTemporaryCredentials) Validate() error {
	if pTypeDef.AccessKeyId == "" {
		return fmt.Errorf("AWSTemporaryCredentials.accessKeyId is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.AccessKeyId)
		if !val.Valid {
			return fmt.Errorf("AWSTemporaryCredentials.accessKeyId does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.SecretAccessKey == "" {
		return fmt.Errorf("AWSTemporaryCredentials.secretAccessKey is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.SecretAccessKey)
		if !val.Valid {
			return fmt.Errorf("AWSTemporaryCredentials.secretAccessKey does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.SessionToken == "" {
		return fmt.Errorf("AWSTemporaryCredentials.sessionToken is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "String", pTypeDef.SessionToken)
		if !val.Valid {
			return fmt.Errorf("AWSTemporaryCredentials.sessionToken does not contain a valid String (%v)", val.Error)
		}
	}
	if pTypeDef.Expiration.IsZero() {
		return fmt.Errorf("AWSTemporaryCredentials: Missing required field: expiration")
	}
	return nil
}

//
// DomainMetricType - zpe metric attributes
//
type DomainMetricType int

//
// DomainMetricType constants
//
const (
	_ DomainMetricType = iota
	ACCESS_ALLOWED
	ACCESS_ALLOWED_DENY
	ACCESS_ALLOWED_DENY_NO_MATCH
	ACCESS_ALLOWED_ALLOW
	ACCESS_ALLOWED_ERROR
	ACCESS_ALLOWED_TOKEN_INVALID
	ACCESS_Allowed_TOKEN_EXPIRED
	ACCESS_ALLOWED_DOMAIN_NOT_FOUND
	ACCESS_ALLOWED_DOMAIN_MISMATCH
	ACCESS_ALLOWED_DOMAIN_EXPIRED
	ACCESS_ALLOWED_DOMAIN_EMPTY
	ACCESS_ALLOWED_TOKEN_CACHE_FAILURE
	ACCESS_ALLOWED_TOKEN_CACHE_NOT_FOUND
	ACCESS_ALLOWED_TOKEN_CACHE_SUCCESS
	ACCESS_ALLOWED_TOKEN_VALIDATE
	LOAD_FILE_FAIL
	LOAD_FILE_GOOD
	LOAD_DOMAIN_GOOD
)

var namesDomainMetricType = []string{
	ACCESS_ALLOWED:                       "ACCESS_ALLOWED",
	ACCESS_ALLOWED_DENY:                  "ACCESS_ALLOWED_DENY",
	ACCESS_ALLOWED_DENY_NO_MATCH:         "ACCESS_ALLOWED_DENY_NO_MATCH",
	ACCESS_ALLOWED_ALLOW:                 "ACCESS_ALLOWED_ALLOW",
	ACCESS_ALLOWED_ERROR:                 "ACCESS_ALLOWED_ERROR",
	ACCESS_ALLOWED_TOKEN_INVALID:         "ACCESS_ALLOWED_TOKEN_INVALID",
	ACCESS_Allowed_TOKEN_EXPIRED:         "ACCESS_Allowed_TOKEN_EXPIRED",
	ACCESS_ALLOWED_DOMAIN_NOT_FOUND:      "ACCESS_ALLOWED_DOMAIN_NOT_FOUND",
	ACCESS_ALLOWED_DOMAIN_MISMATCH:       "ACCESS_ALLOWED_DOMAIN_MISMATCH",
	ACCESS_ALLOWED_DOMAIN_EXPIRED:        "ACCESS_ALLOWED_DOMAIN_EXPIRED",
	ACCESS_ALLOWED_DOMAIN_EMPTY:          "ACCESS_ALLOWED_DOMAIN_EMPTY",
	ACCESS_ALLOWED_TOKEN_CACHE_FAILURE:   "ACCESS_ALLOWED_TOKEN_CACHE_FAILURE",
	ACCESS_ALLOWED_TOKEN_CACHE_NOT_FOUND: "ACCESS_ALLOWED_TOKEN_CACHE_NOT_FOUND",
	ACCESS_ALLOWED_TOKEN_CACHE_SUCCESS:   "ACCESS_ALLOWED_TOKEN_CACHE_SUCCESS",
	ACCESS_ALLOWED_TOKEN_VALIDATE:        "ACCESS_ALLOWED_TOKEN_VALIDATE",
	LOAD_FILE_FAIL:                       "LOAD_FILE_FAIL",
	LOAD_FILE_GOOD:                       "LOAD_FILE_GOOD",
	LOAD_DOMAIN_GOOD:                     "LOAD_DOMAIN_GOOD",
}

//
// NewDomainMetricType - return a string representation of the enum
//
func NewDomainMetricType(init ...interface{}) DomainMetricType {
	if len(init) == 1 {
		switch v := init[0].(type) {
		case DomainMetricType:
			return v
		case int:
			return DomainMetricType(v)
		case int32:
			return DomainMetricType(v)
		case string:
			for i, s := range namesDomainMetricType {
				if s == v {
					return DomainMetricType(i)
				}
			}
		default:
			panic("Bad init value for DomainMetricType enum")
		}
	}
	return DomainMetricType(0) //default to the first enum value
}

//
// String - return a string representation of the enum
//
func (e DomainMetricType) String() string {
	return namesDomainMetricType[e]
}

//
// SymbolSet - return an array of all valid string representations (symbols) of the enum
//
func (e DomainMetricType) SymbolSet() []string {
	return namesDomainMetricType
}

//
// MarshalJSON is defined for proper JSON encoding of a DomainMetricType
//
func (e DomainMetricType) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMetricType
//
func (e *DomainMetricType) UnmarshalJSON(b []byte) error {
	var j string
	err := json.Unmarshal(b, &j)
	if err == nil {
		s := string(j)
		for v, s2 := range namesDomainMetricType {
			if s == s2 {
				*e = DomainMetricType(v)
				return nil
			}
		}
		err = fmt.Errorf("Bad enum symbol for type DomainMetricType: %s", s)
	}
	return err
}

//
// DomainMetric -
//
type DomainMetric struct {
	MetricType DomainMetricType `json:"metricType"`
	MetricVal  int32            `json:"metricVal"`
}

//
// NewDomainMetric - creates an initialized DomainMetric instance, returns a pointer to it
//
func NewDomainMetric(init ...*DomainMetric) *DomainMetric {
	var o *DomainMetric
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetric)
	}
	return o
}

type rawDomainMetric DomainMetric

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMetric
//
func (pTypeDef *DomainMetric) UnmarshalJSON(b []byte) error {
	var r rawDomainMetric
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainMetric(r)
		*pTypeDef = o
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainMetric) Validate() error {
	return nil
}

//
// DomainMetrics -
//
type DomainMetrics struct {

	//
	// name of the domain the metrics pertain to
	//
	DomainName DomainName `json:"domainName"`

	//
	// list of the domains metrics
	//
	MetricList []*DomainMetric `json:"metricList"`
}

//
// NewDomainMetrics - creates an initialized DomainMetrics instance, returns a pointer to it
//
func NewDomainMetrics(init ...*DomainMetrics) *DomainMetrics {
	var o *DomainMetrics
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(DomainMetrics)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (pTypeDef *DomainMetrics) Init() *DomainMetrics {
	if pTypeDef.MetricList == nil {
		pTypeDef.MetricList = make([]*DomainMetric, 0)
	}
	return pTypeDef
}

type rawDomainMetrics DomainMetrics

//
// UnmarshalJSON is defined for proper JSON decoding of a DomainMetrics
//
func (pTypeDef *DomainMetrics) UnmarshalJSON(b []byte) error {
	var r rawDomainMetrics
	err := json.Unmarshal(b, &r)
	if err == nil {
		o := DomainMetrics(r)
		*pTypeDef = *((&o).Init())
		err = pTypeDef.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (pTypeDef *DomainMetrics) Validate() error {
	if pTypeDef.DomainName == "" {
		return fmt.Errorf("DomainMetrics.domainName is missing but is a required field")
	} else {
		val := rdl.Validate(ZTSSchema(), "DomainName", pTypeDef.DomainName)
		if !val.Valid {
			return fmt.Errorf("DomainMetrics.domainName does not contain a valid DomainName (%v)", val.Error)
		}
	}
	if pTypeDef.MetricList == nil {
		return fmt.Errorf("DomainMetrics: Missing required field: metricList")
	}
	return nil
}
